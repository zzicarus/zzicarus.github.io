# 基础部分

## 基础

!!! note "一些注意的地方"
    - **赋值与初始化**其实并不完全相同，初始化是创建变量时赋予一个初始值，赋值是擦除当前值。
    - 一般情况下，这一点并没有任何影响

### 引用

!!! note "引用"
    这是C++中一种新的特性。我们常说的引用指的是左值引用，还有一种引用是指右值引用

#### 左值引用

定义左值引用的使用，一定要赋初始值

```CPP
int value;
int &refVal = value;
int *PtrValue = &value;
// 指向指针的引用
int *&refPointer = PtrValue;  
```

对一个常量的引用可能是一个非常量,`const int &`只是对引用的操作有了限制

```CPP
int i = 10086;
const int m = i;
int &ref_i = i;
const int &Ref_i = i;
ref_i -= 1;
std::cout << "i:" << i << std::endl;
std::cout << "m:" << m << std::endl;   // 10086
std::cout << "i:" << ref_i << std::endl;  // 10085
std::cout << "I:" << Ref_i << std::endl;
```

!!! note "const 引用"
    ```CPP
    double a = 1.12;
    const double &ref_a = a;
    const int &Ref_a = a;
    a = a - 100;
    std::cout << "a:" << ref_a << std::endl;
    std::cout << "A:" << Ref_a << std::endl;

    >> a:-98.88
    >> A:1
    ```
    ![Alt text](images/custom-image.png)

!!! warning
    引用本身并不是一个对象，它`绑定`到一个对象上面去，这意味着它并`不是复制`
    不能够形成一个引用的引用

![image-20240123184813050](https://zzh-pic-for-self.oss-cn-hangzhou.aliyuncs.com/img/202401231848186.png)

### 指针

!!! warning
    在CPP中，指针的初始化最好使用 `nullptr`,相当于void *，而NULL在`cstdlib`中定义，
    ```CPP
    int * a = nullptr;
    ```

### const
>
> const 分为顶层的和底层的。
> 顶层的 Top 表示本身不可变，指向的值不一定
> 底层的 表示本身可变，指向一个不可变的值
> 而指针既可以是Top-level，也可以是Low-level

!!! example

    ```CPP
    int * const a = &i;  // 指针是常量  a顶层的，不能改变  
    const int * b = &j;  // 指向常量的指针
    ```
    其实上面的代码中，`a`是一个指针常量，`b`是一个常量指针；这样侧重后面的一个，可能容易理解一点

#### constexpr和字面值类型

> 是一种常量表达式，C11加入作为一种类型
>
### 处理类型

#### 类型别名

```CPP
typedef double wage;
using wage = double; 
```

!!! warning "typedef"
    使用typedef时，以下两种用法可能带来不同的影响
    ```CPP
    typedef char *prtChar;
    const char*A = &ch;
    const prtChar B = &ch;
    // 这种情况下，B是一个指针；A是一个常量

    typedef char (*prtChar);
    const char *A = &ch;
    const prtChar B = &const_ch;
    // 这种情况下，A、B相同，都是一个指针类型的常量
    ```
!!! Question "为什么是这样定义的"
    Todo  Typedef的实际作用  是如何发生的

#### auto

<span class="box box-blue">C11</span>

> **auto的自动推断，会使得顶层的const失效，保留底层的const**

```CPP
int i = 0;
const int ci = i,&cr = ci;
auto b = ci;	// b is int
auto c = cr;

```

#### decltype

<span class="box box-blue">C11</span>

> 有时候，我们只希望获得一个`Function`的最终运算类型，而不希望由它来赋予初始值

```CPP
int i;
decltype(f()) sum;
const int ci = 0, &cj = ci;
decltype(ci) a = 0; // const int 
decltype(cj) b = a;	// const int &

decltype((i)) c;  //Error!! 引用必须赋予初始值
```

!!! note 
    `decltype(())`的结果永远是引用
    `decltype()`则不然

## 字符串

![Alt text](images/custom-image-1.png)

### 基本操作

```CPP
// Initailize
string s;
string _10c(10,'c');
string _hi("hi");
string s = "value";
// Input
getline(input,receive);
// Method
s.size();   // unsigned int 
s.empty();
// 
string str1 = "World";
string str2 = "Hello";
string str3 = str2 + ", " + str1;
string str4 = "Hello" + " , " + str1; //false

```

!!! warning 
    C++中的字符串的字面值类型并不是标准库string的对象。也就是说，字符串的字面值类型和string不是同一类型。

### cctype

![Alt text](images/custom-image-2.png)



```CPP title="for range"
for (auto c : str)
    cout << c << endl;

for (auto &c : str)
    c = toupper(c);
```

## Vector

```CPP
// Initailize 
vector<int> v1(n, val);
	vector<vector<int>> v2;
	vector<string> v3;
	string word;
	// Method
	while (cin >> word)
		v3.push_back(word);
	v3.empty();
	v3.size();

	vector<int>::size_type;


```

## 一些补充的部分
