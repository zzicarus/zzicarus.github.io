# CN - Labs

>[!abstract] 用于备忘一些实验中的命令/操作
>
> - [计算机网络 Computer Network | 计算机网络课程实验文档 (zjucomp.net)](https://zjucomp.net/)

## 实验一：wireshark抓包

## 实验二：两层交换机

## 实验三：三层交换机

**实验环境配置**

[功能与设备使用介绍 | 计算机网络课程实验文档 (zjucomp.net)](https://zjucomp.net/docs/GNS3/client-usage)

- 退出时可能会消除之前的所有配置，需要手动保存。请确保已经通过设备内的 write 命令保存过配置

## 实验五：OSPF协议

### 概念

- **ADV Router** 指的是 **Advertising Router**，即发布（通告）特定 LSA（Link-State Advertisement，链路状态通告）的路由器

#### **DR（Designated Router，指定路由器）**

定义：

- DR 是 OSPF 广播网络或 NBMA 网络中的核心角色，负责在网络中进行链路状态信息（LSA）的汇总和分发，减少 LSA 泛洪。
- 在每个广播网络中，通过 DR，其他路由器只需与 DR 交换 LSA，而不是与每个路由器进行多对多的交换。

特点：

1. 每个广播或 NBMA 网络中只有一个 DR。
2. DR 的选举是通过 **Router ID** 和优先级决定的。
3. DR 必须与其他路由器建立邻接关系。

选举规则：

1. 路由器优先级最高的成为 DR。
2. 如果优先级相同，Router ID 最大的成为 DR。
3. 路由器优先级为 `0` 时，不参与 DR/BDR 的选举。

#### **BDR** 备用

**定义：**

- BDR 是 DR 的备用角色，在 DR 故障时自动接管 DR 的工作，无需重新选举。
- BDR 的作用是提高 OSPF 网络的可靠性。

**特点：**

1. 每个广播或 NBMA 网络中只有一个 BDR。
2. BDR 与 DR 和其他路由器都建立邻接关系。
3. 在 DR 正常工作时，BDR 不会主动汇总和分发 LSA。

**选举规则：**

1. 路由器优先级仅次于 DR 的成为 BDR。
2. 如果优先级相同，Router ID 次大的成为 BDR。

---

#### 例子

**假设有以下路由器配置：**

| 路由器接口       | IP 地址     |
| ---------------- | ----------- |
| Loopback 0       | 192.168.1.1 |
| GigabitEthernet0 | 10.1.1.1    |
| FastEthernet0    | 172.16.1.1  |

- 如果配置了 `router-id 1.1.1.1`，则 RID 为 `1.1.1.1`。
- 如果没有手动配置 RID，则使用最高的 Loopback 地址：`192.168.1.1`。
- 如果没有配置 Loopback 接口，则使用最高的物理接口地址：`172.16.1.1`。

### **RID 的选取规则**

RID 是在 OSPF 配置中自动或手动选取的，规则如下（优先级从高到低）：

1. **手动配置的 RID**（最高优先级）：

	- 如果在 OSPF 进程中明确指定了 

		```
		router-id
		```

		，OSPF 会优先使用手动配置的值。

		示例命令（在 Cisco 路由器中）：

		```
		python复制代码router ospf 1
		router-id 1.1.1.1
		```

2. **活动的 Loopback 接口地址**：

	- 如果没有手动配置 RID，OSPF 会选择所有活动接口中**最高的 Loopback 接口地址**作为 RID。
	- Loopback 接口通常被优先使用，因为它们不易受到物理链路的中断。

3. **最高的物理接口 IP 地址**：

	- 如果没有手动配置 RID 且没有配置 Loopback 接口，OSPF 会选择**所有物理接口中最高的 IP 地址**作为 RID。

### **邻居（Neighbor）**

在 OSPF（开放式最短路径优先）协议中，**邻居（Neighbor）** 和 **邻接（Adjacency）** 是两个重要的概念，但它们表示的是不同层次的关系。以下是对这两个概念的详细解释：

#### 定义：

OSPF 邻居是指在同一个链路上运行 OSPF 的路由器，通过 OSPF 的 **Hello 协议**发现彼此，并同意建立一种基本的通信关系。

#### 邻居关系的关键点：

- 邻居之间会互相发送和接收 **Hello 包**。
- 邻居状态最低为 **Init**，即接收到对方的 Hello 包。
- 如果双方都在 Hello 包中列出了对方，则邻居状态会升级为 **2-Way**。
- 邻居是 OSPF 建立邻接关系的前提，但不是所有邻居都会成为邻接。

#### 邻居的作用：

- 交换 Hello 包，保持链路活动。
- 确定网络中路由器的基本拓扑结构。
- 为建立邻接关系奠定基础。

#### 示例：

在一个广播网络中，所有运行 OSPF 的路由器在启动后都会成为邻居，但非 DR 和非 BDR 的路由器之间不会进一步建立邻接关系。

------

### 邻接（Adjacency）

#### 定义：

邻接是 OSPF 中更高层次的关系，是指两个路由器之间通过交换完整的链路状态数据库（LSDB）达成一致，从而建立完整的拓扑视图。

#### 邻接关系的关键点：

- 邻接关系建立在邻居关系的基础之上。
- 邻接关系的状态达到 **Full**，即链路状态数据库完全同步。
- 邻接关系的路由器之间会直接交换 **链路状态通告（LSA）**，并在数据库变化时更新信息。
- 并非所有邻居都会成为邻接。

#### 邻接的作用：

- 建立拓扑视图，支持路由计算。
- 减少 OSPF 消息的泛洪，优化路由器的资源使用。
- 支持 LSA 的直接交换。

#### 示例：

在广播网络中：

- **DR（指定路由器）** 和 **BDR（备用指定路由器）** 会与所有其他路由器建立邻接关系。
- 非 DR 和非 BDR 路由器之间不会建立邻接关系。

------

### 邻居与邻接的对比

| 特性         | 邻居（Neighbor）       | 邻接（Adjacency）              |
| ------------ | ---------------------- | ------------------------------ |
| **关系类型** | 基础通信关系           | 完整拓扑同步关系               |
| **建立条件** | 收到并回复 Hello 包    | 邻居关系建立且达成数据库同步   |
| **状态**     | Init、2-Way            | Full                           |
| **消息交换** | Hello 包               | Hello、LSA、LSDB 同步          |
| **适用范围** | 所有运行 OSPF 的路由器 | DR、BDR 与其他路由器，或点对点 |
| **复杂度**   | 低                     | 高                             |
| **功能**     | 保持链路活动，发现对方 | 路由信息同步，支持 LSA 交换    |

------

### **邻居和邻接的状态变化**

OSPF 的路由器关系是通过多个状态逐步发展的，以下是常见状态的演变流程：

1. **Down：**
	- 未收到 Hello 包，链路状态未知。
2. **Init：**
	- 接收到对方的 Hello 包，但尚未确认是否双向通信。
3. **2-Way：**
	- 双方在 Hello 包中互相确认了对方，邻居关系建立。
4. **ExStart：**
	- 准备建立邻接，开始交换数据库信息。
5. **Exchange：**
	- 交换 DBD（Database Description）包，初步同步 LSDB。
6. **Loading：**
	- 通过请求（LSR）和响应（LSU）完成数据库的详细同步。
7. **Full：**
	- LSDB 完全同步，邻接关系建立。

------

###  **适用场景分析**

#### 广播网络（如以太网）：

- DR 和 BDR 与所有其他路由器建立邻接关系。
- 非 DR 和非 BDR 路由器之间只保持邻居关系。

#### 点对点网络（如串行链路）：

- 所有邻居都建立邻接关系，因为点对点网络中没有 DR/BDR。

#### NBMA 网络（非广播多访问）：

- 手动配置的 DR 和 BDR 与其他路由器建立邻接关系。

------

### 总结

- **邻居（Neighbor）：** 基础通信关系，用于维持链路活跃性和发现 OSPF 路由器。
- **邻接（Adjacency）：** 完整拓扑同步关系，用于交换 LSA 和同步 LSDB。
	邻接是邻居关系的进一步发展，不是所有邻居都会成为邻接。

## 实验七：Socket编程